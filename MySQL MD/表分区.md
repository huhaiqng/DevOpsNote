## 表分区的优势

- 可以将单个表存储在不同的磁盘分区上，摆脱磁盘大小的限制，存储更多的数据。

- 通过删除指定的分区，可以更快速的删除数据。同样，添加数据到分区表也更快速。

- 可以使满足条件的查询更快速。查询只会在满足条件的分区上执行。

- SELECT 可以指定要查询的分区，大大的提高了查询速度。

  > 例如: SELECT * FROM t PARTITION (p0,p1) WHERE c < 5;

## 表分区的限制和注意事项

- 分区的InnoDB表不支持外键。

- 分区表上的每个唯一键(包括主键)都必须使用表的分区表达式中的每一列。

  > 分区表可以不包含唯一键。分区表创建后无法新增不包含分区键的唯一键。

- 不要在创建分区表之后更改服务器SQL模式。

- 分区表达式中不允许使用存储过程，存储函数，UDF或插件，声明的变量或用户变量。

- 确保 **large_files_support** 已启用，并且 **open_files_limit** 已正确设置。

- 分区键必须是整数列或解析为整数的表达式。

  > 例外1：通过 **RANGE COLUMNS** 或 **LIST COLUMNS** 进行 分区时，可以使用字符串， DATE，和 DATETIME 列。
  >
  > 例外2：通过 [ LINEAR] KEY 进行分区时，可以使用除 TEXT 和 BLOB 以外的任何有效MySQL数据类型作分区键。

- 表级 **DATA DIRECTORY** 和 **INDEX DIRECTORY** 选项将被忽略。
- 分区表不支持 **FULLTEXT** 索引或搜索。

## 按范围分区

#### 适用范围

- 需要大量删除旧数据。

  ```
   ALTER TABLE employees DROP PARTITION p0; 
  ```

- 表中包含日期或时间的列。
- 经常按分区键进行的范围查询。

#### 创建范围分区表

```
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY RANGE (YEAR(separated)) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1996),
    PARTITION p2 VALUES LESS THAN (2001),
    PARTITION p3 VALUES LESS THAN MAXVALUE
);
```

## 按列表分区

#### 创建列表分区表

```
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY LIST(store_id) (
    PARTITION pNorth VALUES IN (3,5,6,9,17),
    PARTITION pEast VALUES IN (1,2,10,11,19,20),
    PARTITION pWest VALUES IN (4,12,13,14,18),
    PARTITION pCentral VALUES IN (7,8,15,16)
);
```

## 按列分区

#### 特点

- 分区键可以使用多列。

- 分区键可以是非整数的列。

  > DATE 和 DATETIME。
  >
  > CHAR， VARCHAR， BINARY，和 VARBINARY。

#### 范围列分区表

##### 与范围分区表的区别

- RANGE COLUMNS 不接受表达式，仅接受列名。
- RANGE COLUMNS 接受一个或多个列的列表。
- RANGE COLUMNS 分区列不限于整数列；字符串， DATE并且 DATETIME列也可以用作分区列。

##### 创建范围列分区表

```
CREATE TABLE rcx (
     a INT,
     b INT,
     c CHAR(3),
     d INT
)
PARTITION BY RANGE COLUMNS(a,d,c) (
     PARTITION p0 VALUES LESS THAN (5,10,'ggg'),
     PARTITION p1 VALUES LESS THAN (10,20,'mmm'),
     PARTITION p2 VALUES LESS THAN (15,30,'sss'),
     PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE)
);
```

##### 将原先创建的表改为范围列分区表

```
ALTER TABLE employees PARTITION BY RANGE COLUMNS (hired) (
    PARTITION p0 VALUES LESS THAN ('1970-01-01'),
    PARTITION p1 VALUES LESS THAN ('1980-01-01'),
    PARTITION p2 VALUES LESS THAN ('1990-01-01'),
    PARTITION p3 VALUES LESS THAN ('2000-01-01'),
    PARTITION p4 VALUES LESS THAN ('2010-01-01'),
    PARTITION p5 VALUES LESS THAN (MAXVALUE)
);
```

#### 列表列分区表

##### 与列表分区表的区别

- RANGE COLUMNS 不接受表达式，仅接受列名。
- RANGE COLUMNS 接受一个或多个列的列表。
- RANGE COLUMNS 分区列不限于整数列；字符串， DATE并且 DATETIME列也可以用作分区列。

##### 创建列表列分区表

```
CREATE TABLE customers_1 (
    first_name VARCHAR(25),
    last_name VARCHAR(25),
    street_1 VARCHAR(30),
    street_2 VARCHAR(30),
    city VARCHAR(15),
    renewal DATE
)
PARTITION BY LIST COLUMNS(city) (
    PARTITION pRegion_1 VALUES IN('Oskarshamn', 'Högsby', 'Mönsterås'),
    PARTITION pRegion_2 VALUES IN('Vimmerby', 'Hultsfred', 'Västervik'),
    PARTITION pRegion_3 VALUES IN('Nässjö', 'Eksjö', 'Vetlanda'),
    PARTITION pRegion_4 VALUES IN('Uppvidinge', 'Alvesta', 'Växjo')
);
```

## HASH 分区

#### 优势

- 数据分部均衡

#### 创建 HASH 分区表

```
CREATE TABLE employees (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30),
    hired DATE NOT NULL DEFAULT '1970-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT,
    store_id INT
)
PARTITION BY HASH(store_id)
PARTITIONS 4;
```

